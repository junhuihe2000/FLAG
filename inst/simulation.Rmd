---
title: "simulation"
author: "He Junhui"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(devtools)
library(microbenchmark)
library(parallel)
library(Matrix)
library(RSpectra)
library(ggplot2)
library(Rcpp)
library(RcppEigen)
library(RcppParallel)
```

```{r}
Sys.setlocale("LC_ALL","English")
```

```{r}
n = 2400
d = 2
s = 600
r = 3
m = 100
t = 1
X = matrix(rnorm(n*d), n, d)
```

```{r}
cl = makeCluster(8)
microbenchmark({
  U = subsample(X, s, method = "kmeans")
  Z = cross_similarity(X, U, r, cl=cl)
  eigenpairs = truncated_SVD(Z)
},
times = 10)
stopCluster(cl)
```

```{r}
cl = makeCluster(8)
microbenchmark({
  heat_kernel_covariance(X, s, r, m, t, cl=cl)
},
times = 10)
stopCluster(cl)
```

```{r}
x = c(1:1e2)
```

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]

void test_loop(int n, const Rcpp::NumericVector& x ) {
  for(int i=0;i<n;i++){
    x*x;
}
}

```

```{r}
microbenchmark({lapply(c(1:1e3), function(i) {for(j in 1:10) {x*x}})},
               {lapply(c(1:1e4), function(i) {x*x})},
               {for(i in c(1:1e4)) {x*x}},
               {test_loop(1e4, x)},
               times = 10)
```



+ test pgbinary


```{r}
X0 <- matrix(rnorm(50*3), 50, 3)
X1 <- matrix(rnorm(50*3, 3), 50, 3)
Y <- c(rep(1,50),rep(0,50))
X <- rbind(X0,X1)
train_ind = sample(50*2)
X <- X[train_ind,]
Y <- Y[train_ind]
X0_new <- matrix(rnorm(50*3),50,3)
X1_new <- matrix(rnorm(50*3, 3),50,3)
X_new <- rbind(X0_new, X1_new)
Y_new <- c(rep(1,50),rep(0,50))
s <- 10; r <- 3
K <- 10
results <- fit_lae_logit_gp(X, Y, X_new, s, r, K, approach = "posterior", output_cov = TRUE)
Y_pred <- results$Y_pred
C <- results$C
Cvv <- as.matrix(C[1:100,])
Cnv <- as.matrix(C[101:200,])
aug_data <- AugmentedData(Cvv, cbind(Y,1-Y))
# Y_pred <- fit_se_logit_gp(X, Y, X_new, s, r, K, approach = "posterior")
error_rate(Y_new, Y_pred)
```

```{r}
Y_pred = test_pgbinary_cpp(Cvv,Y,Cnv)$Y_pred
error_rate(Y_new, Y_pred)
```



```{r}
X0 <- matrix(rnorm(10*3), 10, 3)
X1 <- matrix(rnorm(10*3, 3), 10, 3)
X2 <- matrix(rnorm(10*3, -3), 10, 3)
Y <- c(rep(0,10), rep(1,10), rep(2,10))
X <- rbind(X0,X1,X2)
train_ind = sample(10*3)
X <- X[train_ind,]
Y <- Y[train_ind]
X0_new <- matrix(rnorm(50*3),50,3)
X1_new <- matrix(rnorm(50*3, 3),50,3)
X2_new <- matrix(rnorm(50*3, -3),50,3)
X_new <- rbind(X0_new, X1_new, X2_new)
Y_new <- c(rep(0,50),rep(1,50),rep(2,50))
s <- 10; r <- 3
K <- 10
J <- 3
Y_pred <- fit_lae_logit_mult_gp(X, Y, X_new, J, s, r, K)
# Y_pred <- fit_se_logit_mult_gp(X, Y, X_new, J, s, r, K)
error_rate(Y_new, Y_pred)
```

```{r}
X_total = rbind(X,X_new)
Y_total = c(Y,Y_new)
ggplot() + geom_point(aes(X_total[,1],X_total[,2],col=Y_total))
ggplot() + geom_point(aes(X_new[,1],X_new[,2],col=Y_new)) +
  geom_point(aes(X[,1],X[,2]),col="red")
```

```{r}
X <- matrix(runif(100, -1, 1), 100, 1)
Y <- c(X)^2 + rnorm(100, 0, 0)
X_new <- matrix(runif(200,-1,1),200,1)
Y_new <- c(X_new)^2
s <- 50; r <- 3
K <- 50
Y_pred = fit_lae_reg_gp(X, Y, X_new, s, r, K)
```

```{r}
ggplot() + geom_line(aes(X_new, Y_new), col="red") +
  geom_line(aes(X_new, Y_pred), col="blue") +
  geom_point(aes(X, Y), col="black")
```

```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;

// [[Rcpp::export(testcpp)]]
void testcpp(const Eigen::RowVectorXd & v) {
  int r = v.size();
  Eigen::RowVectorXd v_desc = v;
  std::sort(v_desc.data(), v_desc.data()+r, std::greater<double>());
  Eigen::RowVectorXd v_cumsum(r);
  std::partial_sum(v_desc.data(), v_desc.data()+r, v_cumsum.data());
  Eigen::RowVectorXd v_star = v_desc.array() - (v_cumsum.array()-1)/Eigen::ArrayXd::LinSpaced(r, 1, r).transpose();
  int rho;
  for(rho=r;rho>0;rho--) {
    if(v_star(rho-1)>0) {break;}
  }

  double theta = (v_desc.head(rho).sum() - 1.0)/rho;
  Eigen::RowVectorXd z = v.array() - theta;
  std::transform(z.data(), z.data()+r, z.data(), [](double a) {return std::max(a, 0.0);});
  cout << "z is \n" << z << endl;
}
```

```{r}
A <- matrix(rnorm(3*3),3,3)
C <- A%*%t(A)
Y <- sample(c(0,1), 3,replace=TRUE)
N <- rep(1,3)
print(marginal_log_likelihood_logit_la(C, Y, N)$amll)
print(marginal_log_likelihood_logit_la_cpp(C, Y, N))
```


```{r}
x = rnorm(5)
U = matrix(rnorm(5*3),3,5)
unit = list(x=x,U=U)
print(local_anchor_embedding(unit))
print(as.vector(local_anchor_embedding_cpp(x,U)))
```


```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
// [[Rcpp::depends(RcppParallel)]]
#include <RcppParallel.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;


template<class ArgType, class RowIndexType, class ColIndexType>
class indexing_functor {
  const ArgType &m_arg;
  const RowIndexType &m_rowIndices;
  const ColIndexType &m_colIndices;
public:
  typedef Eigen::Matrix<typename ArgType::Scalar,
                 RowIndexType::SizeAtCompileTime,
                 ColIndexType::SizeAtCompileTime,
                 ArgType::Flags&Eigen::RowMajorBit?Eigen::RowMajor:Eigen::ColMajor,
                 RowIndexType::MaxSizeAtCompileTime,
                 ColIndexType::MaxSizeAtCompileTime> MatrixType;
 
  indexing_functor(const ArgType& arg, const RowIndexType& row_indices, const ColIndexType& col_indices)
    : m_arg(arg), m_rowIndices(row_indices), m_colIndices(col_indices)
  {}
 
  const typename ArgType::Scalar& operator() (Eigen::Index row, Eigen::Index col) const {
    return m_arg(m_rowIndices[row], m_colIndices[col]);
  }
};


template <class ArgType, class RowIndexType, class ColIndexType>
Eigen::CwiseNullaryOp<indexing_functor<ArgType,RowIndexType,ColIndexType>, typename indexing_functor<ArgType,RowIndexType,ColIndexType>::MatrixType>
mat_indexing(const Eigen::MatrixBase<ArgType>& arg, const RowIndexType& row_indices, const ColIndexType& col_indices)
{
  typedef indexing_functor<ArgType,RowIndexType,ColIndexType> Func;
  typedef typename Func::MatrixType MatrixType;
  return MatrixType::NullaryExpr(row_indices.size(), col_indices.size(), Func(arg.derived(), row_indices, col_indices));
}

// [[Rcpp::export(testindex)]]
void testindex() {
  Eigen::MatrixXd A = Eigen::MatrixXd::Random(3,3);
  cout << "A is\n" << A << endl;
  Eigen::Array2i rows(1,0);
  Eigen::Array2i cols(1,0);
  Eigen::MatrixXd B = mat_indexing(A, rows.transpose(), cols);
  cout << "B is\n" << B << endl;
}
```

```{r}
X <- matrix(rnorm(30), nrow=10, ncol=3)
U <- matrix(rnorm(15), nrow=5, ncol=3)
r <- 3
print(KNN_cpp(X,U,r)[[1]]+1-matrix(unlist(KNN(X,U,r)), 10, 3, byrow=TRUE))
print(KNN_cpp(X,U,r,output = TRUE)[[2]]-KNN(X,U,r,output=TRUE)$distances_sp)
```


```{r}
X <- matrix(rnorm(10*3),10,3)
r <- 3
U <- matrix(rnorm(5*3),5,3)
print(LAE(X, U, r)-LAE_cpp(X,U,r))
microbenchmark(LAE={LAE(X, U, r)},
               LAECPP={LAE_cpp(X, U, r)},
               times = 10)
```

