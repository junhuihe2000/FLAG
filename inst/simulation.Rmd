---
title: "simulation"
author: "He Junhui"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(devtools)
library(microbenchmark)
library(parallel)
library(Matrix)
library(RSpectra)
library(ggplot2)
library(Rcpp)
library(RcppEigen)
library(RcppParallel)
```

```{r}
Sys.setlocale("LC_ALL","English")
```

```{r}
n = 2400
d = 2
s = 600
r = 3
m = 100
t = 1
X = matrix(rnorm(n*d), n, d)
```

```{r}
cl = makeCluster(8)
microbenchmark({
  U = subsample(X, s, method = "kmeans")
  Z = cross_similarity(X, U, r, cl=cl)
  eigenpairs = truncated_SVD(Z)
},
times = 10)
stopCluster(cl)
```

```{r}
cl = makeCluster(8)
microbenchmark({
  heat_kernel_covariance(X, s, r, m, t, cl=cl)
},
times = 10)
stopCluster(cl)
```

```{r}
x = c(1:1e2)
```

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]

void test_loop(int n, const Rcpp::NumericVector& x ) {
  for(int i=0;i<n;i++){
    x*x;
}
}

```

```{r}
microbenchmark({lapply(c(1:1e3), function(i) {for(j in 1:10) {x*x}})},
               {lapply(c(1:1e4), function(i) {x*x})},
               {for(i in c(1:1e4)) {x*x}},
               {test_loop(1e4, x)},
               times = 10)
```



+ test pgbinary


```{r}
X0 <- matrix(rnorm(50*3), 50, 3)
X1 <- matrix(rnorm(50*3, 3), 50, 3)
Y <- c(rep(1,50),rep(0,50))
X <- rbind(X0,X1)
train_ind = sample(50*2)
X <- X[train_ind,]
Y <- Y[train_ind]
X0_new <- matrix(rnorm(50*3),50,3)
X1_new <- matrix(rnorm(50*3, 3),50,3)
X_new <- rbind(X0_new, X1_new)
Y_new <- c(rep(1,50),rep(0,50))
s <- 10; r <- 3
K <- 10
results <- fit_lae_logit_gp(X, Y, X_new, s, r, K, approach = "posterior", output_cov = TRUE)
Y_pred <- results$Y_pred
C <- results$C
Cvv <- as.matrix(C[1:100,])
Cnv <- as.matrix(C[101:200,])
aug_data <- AugmentedData(Cvv, cbind(Y,1-Y))
# Y_pred <- fit_se_logit_gp(X, Y, X_new, s, r, K, approach = "posterior")
error_rate(Y_new, Y_pred)
```

```{r}
Y_pred = test_pgbinary_cpp(Cvv,Y,Cnv)$Y_pred
error_rate(Y_new, Y_pred)
```



```{r}
X0 <- matrix(rnorm(10*3), 10, 3)
X1 <- matrix(rnorm(10*3, 3), 10, 3)
X2 <- matrix(rnorm(10*3, -3), 10, 3)
Y <- c(rep(0,10), rep(1,10), rep(2,10))
X <- rbind(X0,X1,X2)
train_ind = sample(10*3)
X <- X[train_ind,]
Y <- Y[train_ind]
X0_new <- matrix(rnorm(50*3),50,3)
X1_new <- matrix(rnorm(50*3, 3),50,3)
X2_new <- matrix(rnorm(50*3, -3),50,3)
X_new <- rbind(X0_new, X1_new, X2_new)
Y_new <- c(rep(0,50),rep(1,50),rep(2,50))
s <- 10; r <- 3
K <- 10
J <- 3
Y_pred <- fit_lae_logit_mult_gp(X, Y, X_new, J, s, r, K)
# Y_pred <- fit_se_logit_mult_gp(X, Y, X_new, J, s, r, K)
error_rate(Y_new, Y_pred)
```

```{r}
X_total = rbind(X,X_new)
Y_total = c(Y,Y_new)
ggplot() + geom_point(aes(X_total[,1],X_total[,2],col=Y_total))
ggplot() + geom_point(aes(X_new[,1],X_new[,2],col=Y_new)) +
  geom_point(aes(X[,1],X[,2]),col="red")
```

```{r}
X <- matrix(runif(100, -1, 1), 100, 1)
Y <- c(X)^2 + rnorm(100, 0, 0)
X_new <- matrix(runif(200,-1,1),200,1)
Y_new <- c(X_new)^2
s <- 50; r <- 3
K <- 50
Y_pred = fit_lae_reg_gp(X, Y, X_new, s, r, K)
```

```{r}
ggplot() + geom_line(aes(X_new, Y_new), col="red") +
  geom_line(aes(X_new, Y_pred), col="blue") +
  geom_point(aes(X, Y), col="black")
```

```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;

// [[Rcpp::export(testcpp)]]
void testcpp(const Eigen::RowVectorXd & v) {
  int r = v.size();
  Eigen::RowVectorXd v_desc = v;
  std::sort(v_desc.data(), v_desc.data()+r, std::greater<double>());
  Eigen::RowVectorXd v_cumsum(r);
  std::partial_sum(v_desc.data(), v_desc.data()+r, v_cumsum.data());
  Eigen::RowVectorXd v_star = v_desc.array() - (v_cumsum.array()-1)/Eigen::ArrayXd::LinSpaced(r, 1, r).transpose();
  int rho;
  for(rho=r;rho>0;rho--) {
    if(v_star(rho-1)>0) {break;}
  }

  double theta = (v_desc.head(rho).sum() - 1.0)/rho;
  Eigen::RowVectorXd z = v.array() - theta;
  std::transform(z.data(), z.data()+r, z.data(), [](double a) {return std::max(a, 0.0);});
  cout << "z is \n" << z << endl;
}
```

```{r}
A <- matrix(rnorm(3*3),3,3)
C <- A%*%t(A)
Y <- sample(c(0,1), 3,replace=TRUE)
N <- rep(1,3)
print(marginal_log_likelihood_logit_la(C, Y, N)$amll)
print(marginal_log_likelihood_logit_la_cpp(C, Y, N))
```


```{r}
x = rnorm(5)
U = matrix(rnorm(5*3),3,5)
unit = list(x=x,U=U)
print(local_anchor_embedding(unit))
print(as.vector(local_anchor_embedding_cpp(x,U)))
```


```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
// [[Rcpp::depends(RcppParallel)]]
#include <RcppParallel.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;


template<class ArgType, class RowIndexType, class ColIndexType>
class indexing_functor {
  const ArgType &m_arg;
  const RowIndexType &m_rowIndices;
  const ColIndexType &m_colIndices;
public:
  typedef Eigen::Matrix<typename ArgType::Scalar,
                 RowIndexType::SizeAtCompileTime,
                 ColIndexType::SizeAtCompileTime,
                 ArgType::Flags&Eigen::RowMajorBit?Eigen::RowMajor:Eigen::ColMajor,
                 RowIndexType::MaxSizeAtCompileTime,
                 ColIndexType::MaxSizeAtCompileTime> MatrixType;
 
  indexing_functor(const ArgType& arg, const RowIndexType& row_indices, const ColIndexType& col_indices)
    : m_arg(arg), m_rowIndices(row_indices), m_colIndices(col_indices)
  {}
 
  const typename ArgType::Scalar& operator() (Eigen::Index row, Eigen::Index col) const {
    return m_arg(m_rowIndices[row], m_colIndices[col]);
  }
};


template <class ArgType, class RowIndexType, class ColIndexType>
Eigen::CwiseNullaryOp<indexing_functor<ArgType,RowIndexType,ColIndexType>, typename indexing_functor<ArgType,RowIndexType,ColIndexType>::MatrixType>
mat_indexing(const Eigen::MatrixBase<ArgType>& arg, const RowIndexType& row_indices, const ColIndexType& col_indices)
{
  typedef indexing_functor<ArgType,RowIndexType,ColIndexType> Func;
  typedef typename Func::MatrixType MatrixType;
  return MatrixType::NullaryExpr(row_indices.size(), col_indices.size(), Func(arg.derived(), row_indices, col_indices));
}

// [[Rcpp::export(testindex)]]
void testindex() {
  Eigen::MatrixXd A = Eigen::MatrixXd::Random(3,3);
  cout << "A is\n" << A << endl;
  Eigen::Array2i rows(1,0);
  Eigen::Array2i cols(1,0);
  Eigen::MatrixXd B = mat_indexing(A, rows.transpose(), cols);
  cout << "B is\n" << B << endl;
}
```

```{r}
X <- matrix(rnorm(30), nrow=10, ncol=3)
U <- matrix(rnorm(15), nrow=5, ncol=3)
r <- 3
print(KNN_cpp(X,U,r)[[1]]+1-matrix(unlist(KNN(X,U,r)), 10, 3, byrow=TRUE))
print(KNN_cpp(X,U,r,output = TRUE)[[2]]-KNN(X,U,r,output=TRUE)$distances_sp)
```


```{r}
X <- matrix(rnorm(10*3),10,3)
r <- 3
U <- matrix(rnorm(5*3),5,3)
print(LAE(X, U, r)-LAE_cpp(X,U,r))
microbenchmark(LAE={LAE(X, U, r)},
               LAECPP={LAE_cpp(X, U, r)},
               times = 10)
```


```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
// [[Rcpp::depends(RcppParallel)]]
#include <RcppParallel.h>
// [[Rcpp::depends(RSpectra)]]
#include <Spectra/SymEigsSolver.h>
#include <Spectra/MatOp/SparseSymMatProd.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;

// [[Rcpp::export(testtruncated_SVD_cpp)]]
Rcpp::List testtruncated_SVD_cpp(const Eigen::SparseMatrix<double,Eigen::RowMajor> & Z,
                             int K) {
  if(K<0) {
    K = Z.cols();
  }

  Eigen::MatrixXd vectors;
  Eigen::VectorXd values;
  
  // Construct matrix operation object using the wrapper class SparseSymMatProd
  Spectra::SparseSymMatProd<double> W_op((Z.transpose()*Z).pruned());
  
  // Construct eigen solver object, requesting the largest three eigenvalues
  Spectra::SymEigsSolver<Spectra::SparseSymMatProd<double>> eigs(W_op, 3, 6);
  /*
  eigs.init();
  eigs.compute(Spectra::SortRule::LargestAlge);
  if(eigs.info() == Spectra::CompInfo::Successful) {
    values = eigs.eigenvalues();
    vectors = Z * (eigs.eigenvectors() * (1.0/values.array().sqrt()).matrix().asDiagonal());
  } else {
    Rcpp::stop("Truncated SVD fails!")
  }
  */
  
  if(K==Z.cols()) {
    Eigen::BDCSVD<Eigen::MatrixXd> svd(Eigen::MatrixXd(Z), Eigen::ComputeThinU|Eigen::ComputeThinV);
    vectors = svd.matrixU();
    values = svd.singularValues().array().square();
  } else {
    // Construct matrix operation object using the wrapper class SparseSymMatProd
    Spectra::SparseSymMatProd<double> W_op((Z.transpose()*Z).pruned());
    // Construct eigen solver object, requesting the largest three eigenvalues
    Spectra::SymEigsSolver<Spectra::SparseSymMatProd<double>> eigs(W_op, K, 2*K);
    eigs.init();
    eigs.compute(Spectra::SortRule::LargestAlge);
    if(eigs.info() == Spectra::CompInfo::Successful) {
      values = eigs.eigenvalues();
      vectors = Z * (eigs.eigenvectors() * (1.0/values.array().sqrt()).matrix().asDiagonal());
    } else {
      Rcpp::stop("Truncated SVD fails!");
    }
  }
  
  return Rcpp::List::create(Rcpp::Named("values")=values,
                            Rcpp::Named("vectors")=vectors);
}
```

```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;

/*
struct EigenPair {
  Eigen::VectorXd values;
  Eigen::MatrixXd vectors;

  EigenPair(const Eigen::VectorXd & values, const Eigen::MatrixXd & vectors)
    : values(values), vectors(vectors) {}
};

EigenPair truncated_SVD_cpp(const Eigen::SparseMatrix<double,Eigen::RowMajor> & Z,
                             int K) {
  if(K<0) {
    K = Z.cols();
  }

  Eigen::MatrixXd vectors;
  Eigen::VectorXd values;
  if(K==Z.cols()) {
    Eigen::BDCSVD<Eigen::MatrixXd> svd(Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(Z), Eigen::ComputeThinU|Eigen::ComputeThinV);
    vectors = svd.matrixU();
    values = svd.singularValues().array().square();
  } else {
    Rcpp::Environment RSpectra = Rcpp::Environment::namespace_env("RSpectra");
    Rcpp::Function eigs_sym = RSpectra["eigs_sym"];
    Rcpp::List pairs = eigs_sym(Rcpp::Named("A")=Rcpp::wrap(Z.transpose()*Z),
                                Rcpp::Named("k")=K);
    values = Rcpp::as<Eigen::VectorXd>(pairs["values"]);
    vectors = Rcpp::as<Eigen::MatrixXd>(pairs["vectors"]);
    vectors = Z * (vectors * (1.0/values.array().sqrt()).matrix().asDiagonal());
  }

  return EigenPair(values, vectors);
}

*/

// [[Rcpp::export(testspectrum_cpp)]]
void spectrum_from_Z_cpp(const Eigen::SparseMatrix<double,Eigen::RowMajor> & Z,
                         int K,
                        bool root = false) {
  Eigen::VectorXd values;
  Eigen::MatrixXd vectors;
  //EigenPair pairs(values,vectors);
  /*
  Eigen::VectorXd Z_colsum = Eigen::RowVectorXd::Ones(Z.rows()) * Z;
  Eigen::SparseMatrix<double,Eigen::RowMajor> A = Z*(1.0/Z_colsum.array().sqrt()).matrix().asDiagonal();
  EigenPair pairs = truncated_SVD_cpp(A, K);
  
  if(root) {
    pairs.values = pairs.values.array().sqrt().matrix();
  }
  */
  //return Rcpp::List::create(Named("values")=pairs.values, Named("vectors")=pairs.vectors);
}
```



```{r}
X <- matrix(rnorm(5*2), 5, 2)
U <- subsample(X, 2, "random")
r <- 2
as.matrix(cross_similarity_lae_cpp(X,U,2))-as.matrix(cross_similarity(X, U, 2))
```

```{r}
A <- sparseMatrix(i=c(1:10),j=sample.int(10),x=rnorm(10),repr = "R")
K <- 3
print(truncated_SVD(A,K)$value-truncated_SVD_cpp(A,K)$values)
print(as.matrix(truncated_SVD(A,K)$vectors)-truncated_SVD_cpp(A,K)$vectors)
```

```{r}
n = 100
Z <- Matrix::sparseMatrix(i=c(1:n),j=sample.int(n),x=abs(rnorm(n)),repr = "R")
K <- 2
print(spectrum_from_Z(Z,K)$values - spectrum_from_Z_cpp(Z,K)$values)
print(spectrum_from_Z(Z,K)$vectors - spectrum_from_Z_cpp(Z,K)$vectors)
```


```{r}
microbenchmark(spectrum={spectrum_from_Z(Z,K)},
               spectrumcpp={spectrum_from_Z_cpp(Z,K)},
               times = 10)
```



