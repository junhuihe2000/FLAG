---
title: "simulation"
author: "He Junhui"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(devtools)
library(microbenchmark)
library(parallel)
library(Matrix)
library(RSpectra)
library(ggplot2)
library(Rcpp)
library(RcppEigen)
library(RcppParallel)
library(ClusterR)
```

```{r}
Sys.setlocale("LC_ALL","English")
```

```{r}
n = 2400
d = 2
s = 600
r = 3
m = 100
t = 1
X = matrix(rnorm(n*d), n, d)
```

```{r}
cl = makeCluster(8)
microbenchmark({
  U = subsample(X, s, method = "kmeans")
  Z = cross_similarity(X, U, r, cl=cl)
  eigenpairs = truncated_SVD(Z)
},
times = 10)
stopCluster(cl)
```

```{r}
cl = makeCluster(8)
microbenchmark({
  heat_kernel_covariance(X, s, r, m, t, cl=cl)
},
times = 10)
stopCluster(cl)
```

```{r}
x = c(1:1e2)
```

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]

void test_loop(int n, const Rcpp::NumericVector& x ) {
  for(int i=0;i<n;i++){
    x*x;
}
}

```

```{r}
microbenchmark({lapply(c(1:1e3), function(i) {for(j in 1:10) {x*x}})},
               {lapply(c(1:1e4), function(i) {x*x})},
               {for(i in c(1:1e4)) {x*x}},
               {test_loop(1e4, x)},
               times = 10)
```



+ test pgbinary


```{r}
X0 <- matrix(rnorm(50*3), 50, 3)
X1 <- matrix(rnorm(50*3, 3), 50, 3)
Y <- c(rep(1,50),rep(0,50))
X <- rbind(X0,X1)
train_ind = sample(50*2)
X <- X[train_ind,]
Y <- Y[train_ind]
X0_new <- matrix(rnorm(50*3),50,3)
X1_new <- matrix(rnorm(50*3, 3),50,3)
X_new <- rbind(X0_new, X1_new)
Y_new <- c(rep(1,50),rep(0,50))
s <- 10; r <- 3
K <- 10
results <- fit_lae_logit_gp(X, Y, X_new, s, r, K, approach = "posterior", output_cov = TRUE)
Y_pred <- results$Y_pred
C <- results$C
Cvv <- as.matrix(C[1:100,])
Cnv <- as.matrix(C[101:200,])
aug_data <- AugmentedData(Cvv, cbind(Y,1-Y))
# Y_pred <- fit_se_logit_gp(X, Y, X_new, s, r, K, approach = "posterior")
error_rate(Y_new, Y_pred)
```

```{r}
Y_pred = test_pgbinary_cpp(Cvv,Y,Cnv)$Y_pred
error_rate(Y_new, Y_pred)
```



```{r}
X0 <- matrix(rnorm(10*3), 10, 3)
X1 <- matrix(rnorm(10*3, 3), 10, 3)
X2 <- matrix(rnorm(10*3, -3), 10, 3)
Y <- c(rep(0,10), rep(1,10), rep(2,10))
X <- rbind(X0,X1,X2)
train_ind = sample(10*3)
X <- X[train_ind,]
Y <- Y[train_ind]
X0_new <- matrix(rnorm(50*3),50,3)
X1_new <- matrix(rnorm(50*3, 3),50,3)
X2_new <- matrix(rnorm(50*3, -3),50,3)
X_new <- rbind(X0_new, X1_new, X2_new)
Y_new <- c(rep(0,50),rep(1,50),rep(2,50))
s <- 10; r <- 3
K <- 10
J <- 3
Y_pred <- fit_lae_logit_mult_gp(X, Y, X_new, J, s, r, K)
# Y_pred <- fit_se_logit_mult_gp(X, Y, X_new, J, s, r, K)
error_rate(Y_new, Y_pred)
```

```{r}
X_total = rbind(X,X_new)
Y_total = c(Y,Y_new)
ggplot() + geom_point(aes(X_total[,1],X_total[,2],col=Y_total))
ggplot() + geom_point(aes(X_new[,1],X_new[,2],col=Y_new)) +
  geom_point(aes(X[,1],X[,2]),col="red")
```

```{r}
X <- matrix(runif(100, -1, 1), 100, 1)
Y <- c(X)^2 + rnorm(100, 0, 0)
X_new <- matrix(runif(200,-1,1),200,1)
Y_new <- c(X_new)^2
s <- 50; r <- 3
K <- 50
Y_pred = fit_lae_reg_gp(X, Y, X_new, s, r, K)
```

```{r}
ggplot() + geom_line(aes(X_new, Y_new), col="red") +
  geom_line(aes(X_new, Y_pred), col="blue") +
  geom_point(aes(X, Y), col="black")
```

```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;

// [[Rcpp::export(testcpp)]]
void testcpp(const Eigen::RowVectorXd & v) {
  int r = v.size();
  Eigen::RowVectorXd v_desc = v;
  std::sort(v_desc.data(), v_desc.data()+r, std::greater<double>());
  Eigen::RowVectorXd v_cumsum(r);
  std::partial_sum(v_desc.data(), v_desc.data()+r, v_cumsum.data());
  Eigen::RowVectorXd v_star = v_desc.array() - (v_cumsum.array()-1)/Eigen::ArrayXd::LinSpaced(r, 1, r).transpose();
  int rho;
  for(rho=r;rho>0;rho--) {
    if(v_star(rho-1)>0) {break;}
  }

  double theta = (v_desc.head(rho).sum() - 1.0)/rho;
  Eigen::RowVectorXd z = v.array() - theta;
  std::transform(z.data(), z.data()+r, z.data(), [](double a) {return std::max(a, 0.0);});
  cout << "z is \n" << z << endl;
}
```

```{r}
A <- matrix(rnorm(3*3),3,3)
C <- A%*%t(A)
Y <- sample(c(0,1), 3,replace=TRUE)
N <- rep(1,3)
print(marginal_log_likelihood_logit_la(C, Y, N)$amll)
print(marginal_log_likelihood_logit_la_cpp(C, Y, N))
```


```{r}
x = rnorm(5)
U = matrix(rnorm(5*3),3,5)
unit = list(x=x,U=U)
print(local_anchor_embedding(unit))
print(as.vector(local_anchor_embedding_cpp(x,U)))
```


```{Rcpp}
// [[Rcpp::depends(RcppEigen)]]
#include <RcppEigen.h>
// [[Rcpp::depends(RcppParallel)]]
#include <RcppParallel.h>
// [[Rcpp::depends(nloptr)]]
#include <nloptrAPI.h>
#include <iostream>
#include <algorithm>
#include <numeric>

using namespace Rcpp;
using namespace Eigen;
using namespace std;


//[[Rcpp::export(testcout)]]
void testcout() {
  std::string approach = "posterior";
  std::cout << (approach=="posterior") << std::endl;
  std::cout << approach << std::endl;
  Rcpp::NumericVector v;
  Eigen::VectorXd v_eig = Rcpp::as<Eigen::VectorXd>(v);
  std::cout << v_eig.size() << std::endl;
}


```

```{r}
X0 <- matrix(rnorm(3*3), 3, 3)
X1 <- matrix(rnorm(3*3, 5), 3, 3)
Y <- c(1,1,1,0,0,0)
X <- rbind(X0,X1)
X0_new <- matrix(rnorm(10*3),10,3)
X1_new <- matrix(rnorm(10*3, 5),10,3)
X_new <- rbind(X0_new, X1_new)
Y_new <- c(rep(1,10),rep(0,10))
s <- 6; r <- 3
K <- 5
fit_lae_logit_gp(X,Y,X_new,s,r,K)
```

```{r}
microbenchmark(HK={HK_from_spectrum(eigens, K, t, idx0, idx1)},
               HK_cpp={testhk(eigens, K, t, idx0-1, idx1-1)},
               times = 10)
```

