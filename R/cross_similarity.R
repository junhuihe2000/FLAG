#' Compute cross similarity matrix Z between X and U
#'
#' @param X A numeric matrix with dim (n,d), original sample,
#' each row indicates one original point in R^d.
#' @param U A numeric matrix with dim (s,d) or (s,d+1), sub-sample,
#' each row indicates one representative point in R^d,
#' where the d+1 column indicates the number of points in each cluster if it exists.
#' @param r An integer, the number of the nearest neighbor points.
#' @param kernel A character vectors in c("lae"), the type of kernel in computing
#' the cross similarity matrix Z, the defaulting value is "lae".
#' @param gl A character vector in c("rw", "normalized", "cluster-normalized"),
#' indicates how to construct the stochastic transition matrix. "rw" means random walk,
#' "normalized" means normalized random walk, "cluster-normalized" means
#' normalized random walk with cluster membership re-balance. The defaulting gl
#' is "rw".
#' @param cl he cluster to make parallel computing,
#' typically generated by parallel::makeCluster(num_workers).
#' The defaulting value of cl is NULL, that is, sequential computing.
#'
#' @return A numeric matrix with dim (n,s),
#' the stochastic transition matrix from X to U.
#' @export
#'
#' @examples
#' X <- matrix(rnorm(5*2), 5, 2)
#' U <- subsample(X, 2, "random")
#' cross_similarity(X, U, 2)
cross_similarity <- function(X, U, r=3L, kernel="lae", gl="rw", cl=NULL) {
  stopifnot(ncol(U)-ncol(X)==0||ncol(U)-ncol(X)==1, r<=nrow(U))
  d = ncol(X)

  if(kernel=="lae") {
    Z = LAE(X, U[,1:d, drop=FALSE], r, cl=cl)
  } else {
    stop("Error: the kernel is not supported!")
  }

  if(gl=="rw") {
    Z = Matrix::rowScale(Z, Matrix::rowSums(Z)^{-1})
  } else if(gl=="normalized") {
    Z_norm = Matrix::colScale(Z, Matrix::colSums(Z)^{-1})
    Z = Matrix::rowScale(Z_norm, Matrix::rowSums(Z_norm)^{-1})
  } else if(gl=="cluster-normalized") {
    if(ncol(U)!=(ncol(X)+1)) {
      stop("Error: the subsample method is not clustering!")
    }
    Z_norm = Matrix::colScale(Z, Matrix::colSums(Z)^{-1})
    Z_cl = Matrix::colScale(Z_norm, U[,d+1])
    Z = Matrix::rowScale(Z_cl, Matrix::rowSums(Z_cl)^{-1})
  } else {
    stop("Error: the type of graph Laplacian is not supported!")
  }

  return(Z)
}
