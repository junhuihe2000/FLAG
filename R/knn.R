#' k-nearest neighbor reference points
#'
#' @param X Original points, a (n,d) matrix, each row indicates one original point.
#' @param U Reference points, a (s,d) or (s,d+1) matrix, each row indicates one reference point.
#' @param r The number of k-nearest neighbor points, an integer.
#' @param distance The distance method to compute k-nearest neighbor points, characters in c("Euclidean", "geodesic"),
#'  including Euclidean distance and geodesic distance, the defaulting distance
#'  is Euclidean distance.
#' @param output Bool, whether to output the distance matrix, defaulting value is `FALSE`.
#' @param cl The cluster to make parallel computing,
#' typically generated by parallel::makeCluster(num_workers).
#' The defaulting value of cl is NULL, that is, sequential computing.
#'
#' @return If `output=FALSE`, the indexes of KNN, a list with length n, each component of the list is a vector of length r,
#'  indicating the indexes of KNN for the corresponding original point based on the chosen distance.
#'  Otherwise `output=TRUE`, a list with two components, the one is the indexes of KNN,
#'  the other is the sparse distance matrix with dim(n,s).
#' @export
#'
#' @examples
#' X <- matrix(rnorm(300), nrow=100, ncol=3)
#' U <- matrix(rnorm(30), nrow=10, ncol=3)
#' r <- 3
#' distance <- "Euclidean"
#' KNN(X, U, r, distance)
KNN <- function(X, U, r, distance="Euclidean", output=FALSE, cl=NULL) {
  stopifnot(is.matrix(X), is.matrix(U), abs(r-round(r))<.Machine$double.eps^0.5, ncol(X)==ncol(U))
  n = nrow(X)
  if(distance=="Euclidean") {
    distances = rowSums(X^2)-2*X%*%t(U) + matrix(rowSums(U^2), n, nrow(U), byrow = TRUE)
  } else {
    stop("Error: the distance of KNN is not supported!")
  }
  distances_list = lapply(c(1:n), function(i) {return(distances[i,])})

  if(is.null(cl)) {
    ind_knn = lapply(distances_list, which_minn, r=r)
  } else if(methods::is(cl, "cluster")) {
    ind_knn = parallel::parLapply(cl, distances_list, which_minn, r=r)
  } else {
    stop("Error: the value of cl is illegal!")
  }

  if(output==FALSE) {
    return(ind_knn)
  } else {
    i = rep(c(1:n), each=r); j = unlist(ind_knn)
    distances_sp = Matrix::sparseMatrix(i=i,j=j,x=distances[cbind(i,j)])
    return(list(ind_knn=ind_knn, distances_sp=distances_sp))
  }

}



#' Find indexes of the first r smallest elements in arrays based on Bubblesorting
#'
#' @param z A vector of length s, including elements to be sorted.
#' @param r The number of the smallest elements, an integer.
#'
#' @return A vector of length r, indicating the indexes of the first r smallest elements.
#' @export
#'
#' @examples
#' z <- c(1,3,2)
#' r <- 2
#' which_minn(z, r)
which_minn <- function(z, r) {
  stopifnot(is.vector(z), abs(r-round(r))<.Machine$double.eps^0.5)
  return(order(z)[1:r])
}
